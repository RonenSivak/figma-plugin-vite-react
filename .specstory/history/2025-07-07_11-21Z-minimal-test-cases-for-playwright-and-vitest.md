<!-- Generated by SpecStory -->

# Minimal test cases for playwright and vitest (2025-07-07 11:21Z)

_**User**_

we want minimal test examples. write only 2 test cases for playwrite and the vitest.
also make sure the drivers are also minimal (but have the same structure).
for the e2e i want a normal UI example and example with interceptors.
for vitest i want normal example and example with communication

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user wants me to create minimal test examples for this figma plugin MVP project. They want:

1. For Playwright (e2e tests):
   - 2 test cases 
   - One normal UI example
   - One example with interceptors
   - The drivers should be minimal but have the same structure

2. For Vitest:
   - 2 test cases
   - One normal example
   - One example with communication

Let me first understand the current structure by looking at the existing test files to understand the current patterns and what needs to be modified.

From the project structure I can see:
- There are existing e2e tests in `tests/e2e/` with `app.spec.ts` and `app.test.driver.ts`
- There are existing unit tests in `src/test/` with `App.test.tsx` and `App.test.driver.tsx`
- There's also `interceptPostMessage.ts` in e2e which seems to be related to the interceptor functionality

Let me examine the current test files to understand their structure and then create minimal versions.</details></think>

---

I'll help you create minimal test examples for both Playwright (e2e) and Vitest. Let me first examine the current test structure to understand the patterns and then create minimal versions.

---

Read file: tests/e2e/app.spec.ts

---

Read file: tests/e2e/app.test.driver.ts

---

Read file: tests/e2e/interceptPostMessage.ts

---

<think><details><summary>Thought Process</summary>Now let me examine the current vitest unit tests to understand their structure:</details></think>

---

Read file: src/test/App.test.driver.tsx

---

Read file: src/app/App.test.tsx

---

<think><details><summary>Thought Process</summary>Now I understand the current structure. I need to create minimal test examples based on what the user requested:

1. For Playwright (e2e tests):
   - 2 test cases 
   - One normal UI example
   - One example with interceptors
   - The drivers should be minimal but have the same structure

2. For Vitest:
   - 2 test cases
   - One normal example
   - One example with communication

Let me create minimal versions. I'll create entirely new files with just the essential structure and functionality.

First, let me look at some other configuration files to understand the setup better:</details></think>

---

Read file: playwright.config.ts

---

Read file: vitest.config.ts

---

<think><details><summary>Thought Process</summary>Now I have a clear understanding of the structure. Let me create minimal test examples according to the user's requirements:

1. For Playwright (e2e tests): I'll create minimal versions with 2 test cases:
   - One normal UI example (basic UI interaction)
   - One example with interceptors (using the mock response system)

2. For Vitest: I'll create minimal versions with 2 test cases:
   - One normal example (basic component testing)  
   - One example with communication (mocking the plugin communication)

Let me create these files:</details></think>

---

Now I'll create minimal test examples for both Playwright and Vitest based on your requirements. I'll create clean, simple versions that maintain the same structure but with minimal functionality.

---

```diff
  import { createE2eDriver } from './app.test.driver'
  
- test.describe('Figma Plugin App - E2E Tests', () => {
-   test.describe.configure({ mode: 'parallel' })
- 
-   test('should render the main app interface after plugin bootstraps', async ({ page }) => {
+ test.describe('Figma Plugin - Minimal E2E Tests', () => {
+   test('should render basic UI elements', async ({ page }) => {
      const driver = createE2eDriver(page)
      
-     await driver.set.setupTestEnvironment()
+     await driver.set.setupBasicEnvironment()
      await driver.get.expectMainAppVisible()
+     await driver.get.expectPingButtonEnabled()
    })
  
-   test('should display mocked API responses when pinging plugin', async ({ page }) => {
+   test('should handle intercepted ping with custom response', async ({ page }) => {
      const driver = createE2eDriver(page)
      
-     await driver.set.setupTestEnvironment()
-     
-     // Test ping functionality with response verification
-     await driver.when.clickPing()
-     await driver.when.waitForLoading('Pinging...')
-     await driver.get.expectResponse('Pong received! Count: 1')
-     
-     // Test ping again to verify counter increment
-     await driver.when.clickPing()
-     await driver.when.waitForLoading('Pinging...')
-     await driver.get.expectResponse('Pong received! Count: 2')
-   })
- 
-   test('should handle message sending with response display', async ({ page }) => {
-     const driver = createE2eDriver(page)
-     
-     await driver.set.setupTestEnvironment()
-     
-     // Verify initial state
-     await driver.get.expectButtonDisabled(driver.get.sendButton())
-     
-     // Send message and verify response
-     await driver.when.sendMessage('Hello Figma Test!')
-     await driver.when.waitForLoading('Sending...')
-     await driver.get.expectResponse('Message received: "Hello Figma Test!"')
-     
-     // Verify input cleared and button disabled
-     await driver.get.expectInputEmpty(driver.get.messageInput())
-     await driver.get.expectButtonDisabled(driver.get.sendButton())
-   })
- 
-   test('should handle text creation with response display', async ({ page }) => {
-     const driver = createE2eDriver(page)
-     
-     await driver.set.setupTestEnvironment()
-     
-     // Verify initial state
-     await driver.get.expectButtonDisabled(driver.get.createTextButton())
-     
-     // Create text and verify response
-     await driver.when.createText('Sample Text Node')
-     await driver.when.waitForLoading('Creating...')
-     await driver.get.expectResponse('Text node created: "Sample Text Node"')
-     
-     // Verify input cleared and button disabled
-     await driver.get.expectInputEmpty(driver.get.textInput())
-     await driver.get.expectButtonDisabled(driver.get.createTextButton())
-   })
- 
-   test('should handle custom mock responses', async ({ page }) => {
-     const driver = createE2eDriver(page)
-     
-     // Configure custom mock responses
-     await driver.set.postMessageInterceptor({
-       mockResponses: {
-         ping: (payload) => `Custom ping response with count: ${payload[0] || 1}`,
-         message: (payload) => `Custom message handler received: ${payload[0] || 'empty'}`,
-         createText: (payload) => `Successfully created text node: "${payload[0] || 'default'}" with custom handler`,
-         customEvent: (payload) => `Custom event response: ${JSON.stringify(payload)}`
-       },
-       delay: 50, // Faster response for this test
-       enableLogging: true
-     })
-     
-     await driver.set.navigateToApp()
-     await driver.set.waitForPluginReady()
-     
-     // Test custom ping response
+     await driver.set.setupWithInterceptor({
+       ping: () => 'Custom intercepted response!'
+     })
+     
      await driver.when.clickPing()
-     await driver.when.waitForLoading('Pinging...')
-     await driver.get.expectResponse('Custom ping response with count: 1')
-     
-     // Test custom message response
-     await driver.when.sendMessage('Test custom message')
-     await driver.when.waitForLoading('Sending...')
-     await driver.get.expectResponse('Custom message handler received: Test custom message')
-     
-     // Test custom text creation response
-     await driver.when.createText('Custom text')
-     await driver.when.waitForLoading('Creating...')
-     await driver.get.expectResponse('Successfully created text node: "Custom text" with custom handler')
+     await driver.get.expectResponse('Custom intercepted response!')
    })
  }) 
```

---

```diff
  import { expect, Page } from '@playwright/test'
- import { createPostMessageInterceptor, defaultMockResponses, MockResponseConfig, InterceptPostMessageOptions } from './interceptPostMessage'
+ import { createPostMessageInterceptor, MockResponseConfig } from './interceptPostMessage'
  
  export class E2eTestDriver {
```

```diff
    // GET - Element queries and assertions
    get = {
-     // Element Queries
      title: () => this.page.getByText('🎯 Figma Plugin'),
      pingButton: () => this.page.getByRole('button', { name: /ping/i }),
-     sendButton: () => this.page.getByRole('button', { name: /send/i }),
-     createTextButton: () => this.page.getByRole('button', { name: /create text/i }),
-     messageInput: () => this.page.getByPlaceholder("Type message (e.g., 'Hi')"),
-     textInput: () => this.page.getByPlaceholder('Enter text to create in Figma'),
-     loadingText: () => this.page.getByText('Initializing Plugin...'),
-     
-     // Response Elements
-     response: (text: string) => this.page.getByText(text),
-     
-     // Assertions
+     
      expectMainAppVisible: async () => {
        await expect(this.get.title()).toBeVisible()
        return this
      },
  
-     expectLoadingState: async () => {
-       await expect(this.get.loadingText()).toBeVisible()
+     expectPingButtonEnabled: async () => {
+       await expect(this.get.pingButton()).toBeEnabled()
        return this
      },
  
-     expectResponse: async (expectedText: string, timeout = 3000) => {
-       await expect(this.get.response(expectedText)).toBeVisible({ timeout })
-       return this
-     },
- 
-     expectButtonEnabled: async (buttonLocator: ReturnType<typeof this.page.getByRole>) => {
-       await expect(buttonLocator).toBeEnabled()
-       return this
-     },
- 
-     expectButtonDisabled: async (buttonLocator: ReturnType<typeof this.page.getByRole>) => {
-       await expect(buttonLocator).toBeDisabled()
-       return this
-     },
- 
-     expectInputValue: async (inputLocator: ReturnType<typeof this.page.getByPlaceholder>, value: string) => {
-       await expect(inputLocator).toHaveValue(value)
-       return this
-     },
- 
-     expectInputEmpty: async (inputLocator: ReturnType<typeof this.page.getByPlaceholder>) => {
-       await expect(inputLocator).toHaveValue('')
+     expectResponse: async (expectedText: string) => {
+       await expect(this.page.getByText(expectedText)).toBeVisible({ timeout: 3000 })
        return this
      }
```

```diff
        await this.get.pingButton().click()
        return this
-     },
- 
-     typeMessage: async (message: string) => {
-       await this.get.messageInput().fill(message)
-       return this
-     },
- 
-     sendMessage: async (message: string) => {
-       await this.when.typeMessage(message)
-       await this.get.sendButton().click()
-       return this
-     },
- 
-     typeText: async (text: string) => {
-       await this.get.textInput().fill(text)
-       return this
-     },
- 
-     createText: async (text: string) => {
-       await this.when.typeText(text)
-       await this.get.createTextButton().click()
-       return this
-     },
- 
-     waitForLoading: async (loadingText: string) => {
-       await expect(this.page.getByText(loadingText)).toBeVisible()
-       return this
-     }
+     }
    }
  
-   // SET - Setup, configuration, and mocking
+   // SET - Setup and configuration
    set = {
-     postMessageInterceptor: async (config: Partial<InterceptPostMessageOptions>) => {
-       // Listen to console messages for debugging
-       this.page.on('console', msg => {
-         console.log(`PAGE LOG: ${msg.type()}: ${msg.text()}`)
-       })
- 
-       // Use default mock responses if none provided
-       const options: InterceptPostMessageOptions = {
-         mockResponses: defaultMockResponses,
-         delay: 100,
-         enableLogging: true,
-         ...config
-       }
- 
-       // Inject the configurable postMessage interceptor
-       const interceptorScript = createPostMessageInterceptor(options)
-       await this.page.addInitScript(interceptorScript)
- 
-       return this
-     },
- 
-     setupMocks: async (mockResponses?: MockResponseConfig) => {
-       return this.set.postMessageInterceptor({
-         mockResponses: mockResponses || defaultMockResponses
-       })
-     },
- 
-     navigateToApp: async () => {
+     setupBasicEnvironment: async () => {
        await this.page.goto('/')
-       return this
-     },
- 
-     waitForPluginReady: async () => {
-       // Wait for loading state to appear
-       await this.get.expectLoadingState()
- 
-       // Simulate plugin ready signal
        await this.page.evaluate(() => {
-         // Simulate the 'ready' message from plugin to complete bootstrap
+         // Simulate plugin ready
          window.dispatchEvent(new MessageEvent('message', {
            data: {
              pluginId: 'test-plugin',
-             pluginMessage: {
-               messageId: 'test-ready',
-               fromSide: 'Plugin-side',
-               eventName: 'ready',
-               payload: []
-             }
+             pluginMessage: { eventName: 'ready', payload: [] }
            }
          }))
        })
- 
-       // Wait for main app to be visible
-       await this.get.expectMainAppVisible()
        return this
      },
  
-     setupTestEnvironment: async () => {
-       await this.set.setupMocks()
-       await this.set.navigateToApp()
-       await this.set.waitForPluginReady()
+     setupWithInterceptor: async (mockResponses: MockResponseConfig) => {
+       const interceptorScript = createPostMessageInterceptor({
+         mockResponses,
+         delay: 50,
+         enableLogging: false
+       })
+       await this.page.addInitScript(interceptorScript)
+       await this.set.setupBasicEnvironment()
        return this
      }
    }
  }
  
- // Helper to create driver instance for tests
  export const createE2eDriver = (page: Page) => new E2eTestDriver(page) 
```

---

```diff
  export interface MockResponseConfig {
-   [eventName: string]: (payload: unknown[]) => string | null
+   [eventName: string]: (payload?: unknown[]) => string
  }
  
```

```diff
   */
  export const createPostMessageInterceptor = (options: InterceptPostMessageOptions): string => {
-   const { mockResponses, delay = 100, enableLogging = true } = options
+   const { mockResponses, delay = 100, enableLogging = false } = options
    
-   // Convert function definitions to strings that can be injected
    const mockResponseFunctions = Object.entries(mockResponses)
      .map(([eventName, func]) => `'${eventName}': ${func.toString()}`)
      .join(',\n    ')
    
    return `
-     // Store original console.log for debugging
-     const originalLog = console.log;
-     
-     // Mock parent.postMessage to intercept UI -> Plugin messages
      window.parent.postMessage = (message) => {
        if (${enableLogging}) {
-         originalLog('Intercepted postMessage:', message);
+         console.log('Intercepted:', message);
        }
        
-       // Check if this is a plugin message
        if (message?.pluginMessage) {
-         const pluginMessage = message.pluginMessage;
-         if (${enableLogging}) {
-           originalLog('Plugin message:', pluginMessage);
-         }
+         const { eventName, payload, messageId } = message.pluginMessage;
          
-         // Simulate plugin response after a delay
          setTimeout(() => {
-           const mockResponse = generateMockResponse(pluginMessage);
-           if (mockResponse) {
-             if (${enableLogging}) {
-               originalLog('Sending mock response:', mockResponse);
-             }
-             
-             // Simulate plugin response by dispatching MessageEvent
+           const mockResponses = { ${mockResponseFunctions} };
+           
+           if (mockResponses[eventName]) {
+             const responseText = mockResponses[eventName](payload);
+             
              window.dispatchEvent(new MessageEvent('message', {
                data: {
                  pluginId: 'mock-plugin',
-                 pluginMessage: mockResponse
+                 pluginMessage: {
+                   messageId,
+                   eventName: '__INTERNAL_SUCCESS_RESPONSE_EVENT',
+                   payload: [responseText]
+                 }
                }
              }));
            }
          }, ${delay});
        }
-       
-       // Don't call original postMessage to avoid errors
-     };
-     
-     // Function to generate mock responses based on the configuration
-     function generateMockResponse(pluginMessage) {
-       const { eventName, payload, messageId } = pluginMessage;
-       
-       if (${enableLogging}) {
-         originalLog(\`Generating mock response for eventName: \${eventName}, payload:\`, payload);
-       }
-       
-       // Define mock response functions
-       const mockResponses = {
-         ${mockResponseFunctions}
-       };
-       
-       // Check if we have a mock response for this event
-       if (mockResponses[eventName]) {
-         try {
-           // Call the mock response function with the payload
-           const responseText = mockResponses[eventName](payload || []);
-           
-           if (responseText) {
-             if (${enableLogging}) {
-               originalLog(\`Generated \${eventName} response: \${responseText}\`);
-             }
-             
-             return {
-               messageId,
-               fromSide: 'Plugin-side',
-               eventName: '__INTERNAL_SUCCESS_RESPONSE_EVENT',
-               payload: [responseText]
-             };
-           }
-         } catch (error) {
-           if (${enableLogging}) {
-             originalLog(\`Error generating mock response for \${eventName}:\`, error);
-           }
-         }
-       }
-       
-       if (${enableLogging}) {
-         originalLog(\`No mock response configured for eventName: \${eventName}\`);
-       }
-       return null;
-     }
-     
-     if (${enableLogging}) {
-       originalLog('postMessage interceptor installed with mock response handlers for:', Object.keys({${mockResponseFunctions}}));
-     }
+     };
    `;
  }
```

---

```diff
  import { AppTestDriver } from '../test/App.test.driver'
  
- describe('Figma Plugin App - User Scenarios', () => {
+ describe('Figma Plugin - Minimal Unit Tests', () => {
    let driver: AppTestDriver
  
```

```diff
    })
  
-   describe('Application Startup', () => {
-     it('shows loading screen while plugin initializes', () => {
-       driver
-         .set.renderApp()
-         .get.expectLoadingState()
-         .get.expectBootstrapCallbackSet()
-     })
- 
-     it('transitions to main interface when plugin is ready', async () => {
-       const readyDriver = await driver
-         .set.renderApp()
-         .set.makePluginReady()
-       
-       readyDriver.get.expectMainUI()
-     })
+   it('should render basic UI elements', async () => {
+     await driver
+       .set.renderApp()
+       .set.makePluginReady()
+       .get.expectMainUI()
    })
  
-   describe('Basic Plugin Communication', () => {
-     beforeEach(async () => {
-       await driver.set.loadReadyApp()
-     })
- 
-     it('user can ping the plugin', async () => {
-       const result = await driver
-         .set.mockRequestSuccess('pong')
-         .when.clickPing()
-       
-       result.get.expectPingRequest(1)
-     })
- 
-     it('user can send messages to plugin', async () => {
-       const result = await driver
-         .set.mockRequestSuccess('received')
-         .when.sendMessage('Hello')
-       
-       result.get.expectMessageRequest('Hello')
-     })
-   })
- 
-   describe('Text Click Detection & Key Generation', () => {
-     beforeEach(async () => {
-       await driver.set.loadReadyApp()
-     })
- 
-     it('detects when user clicks text in Figma and generates babel key', async () => {
-       const afterClick = await driver.when.simulateTextClick('node1', 'Hello World')
-       await afterClick.get.expectClickDetection('node1', 'Hello World')
-       const afterGenerate = await afterClick.when.clickGenerateKey()
-       await afterGenerate.get.expectGeneratedKey('babel.key.hello-world')
-     })
-   })
- 
-   describe('Error Scenarios', () => {
-     beforeEach(async () => {
-       await driver.set.loadReadyApp()
-     })
- 
-     it('displays error when plugin communication fails', async () => {
-       const result = await driver
-         .set.mockRequestError(new Error('Network error'))
-         .when.clickPing()
-       
-       await result.get.expectErrorMessage('Error: Network error')
-     })
+   it('should handle ping communication', async () => {
+     await driver
+       .set.loadReadyApp()
+       .set.mockRequestSuccess('pong response')
+       .when.clickPing()
+       .get.expectPingRequest(1)
    })
  }) 
```

---

```diff
  import { render, screen, waitFor } from './test-utils'
  import userEvent from '@testing-library/user-event'
- import type { UserEvent } from '@testing-library/user-event'
  import App from '../app/App'
  
- // Mock setup - encapsulated in driver
+ // Mock setup
  vi.mock('../app/App.network', () => ({
    UI_CHANNEL: {
      request: vi.fn(),
-     emit: vi.fn(),
-     registerMessageHandler: vi.fn(),
    },
    setBootstrapCallback: vi.fn(),
  }))
- 
- vi.mock('../common/networks', () => ({
-   PLUGIN: 'PLUGIN',
-   UI: 'UI',
- }))
  
  import { UI_CHANNEL, setBootstrapCallback } from '../app/App.network'
  
  export class AppTestDriver {
-   private user: UserEvent
+   private user = userEvent.setup()
    private mockRequest = vi.mocked(UI_CHANNEL.request)
    private mockSetBootstrapCallback = vi.mocked(setBootstrapCallback)
  
-   constructor() {
-     this.user = userEvent.setup()
-   }
- 
-   // GET - Retrieve elements, state, and perform assertions
+   // GET - Element queries and assertions
    get = {
-     // Element Queries
-     loadingText: () => screen.getByText('Initializing Plugin...'),
-     waitingText: () => screen.getByText('Waiting for Figma plugin to load'),
      mainTitle: () => screen.getByText('🎯 Figma Plugin'),
      pingButton: () => screen.getByText('🏓 Ping'),
-     sendButton: () => screen.getByText('📤 Send'),
-     createTextButton: () => screen.getByText('📝 Create Text'),
-     messageInput: () => screen.getByPlaceholderText('Type message (e.g., \'Hi\')'),
-     textInput: () => screen.getByPlaceholderText('Enter text to create in Figma'),
-     generateKeyButton: () => screen.getByText('🔑 Generate Key'),
- 
-     // State Checks
-     hasElement: (text: string): boolean => {
-       try {
-         screen.getByText(text)
-         return true
-       } catch {
-         return false
-       }
-     },
- 
-     // Assertions
-     expectLoadingState: () => {
-       expect(screen.getByText('Initializing Plugin...')).toBeInTheDocument()
-       expect(screen.getByText('Waiting for Figma plugin to load')).toBeInTheDocument()
-       return this
-     },
- 
+     
      expectMainUI: () => {
-       expect(screen.getByText('🎯 Figma Plugin')).toBeInTheDocument()
-       expect(screen.getByText('🏓 Ping')).toBeInTheDocument()
-       expect(screen.getByText('📤 Send')).toBeInTheDocument()
-       expect(screen.getByText('📝 Create Text')).toBeInTheDocument()
-       return this
-     },
- 
-     expectBootstrapCallbackSet: () => {
-       expect(this.mockSetBootstrapCallback).toHaveBeenCalledWith(expect.any(Function))
+       expect(this.get.mainTitle()).toBeInTheDocument()
+       expect(this.get.pingButton()).toBeInTheDocument()
        return this
      },
```

```diff
        expect(this.mockRequest).toHaveBeenCalledWith('PLUGIN', 'ping', [count])
        return this
-     },
- 
-     expectMessageRequest: (message: string) => {
-       expect(this.mockRequest).toHaveBeenCalledWith('PLUGIN', 'message', [message])
-       return this
-     },
- 
-     expectErrorMessage: async (errorText: string) => {
-       await waitFor(() => {
-         expect(screen.getByText(`Error: ${errorText}`)).toBeInTheDocument()
-       })
-       return this
-     },
- 
-     expectClickDetection: async (nodeId: string, text: string) => {
-       await waitFor(() => {
-         expect(screen.getByText('Auto-detected click:')).toBeInTheDocument()
-         expect(screen.getByText(`user clicked on ${nodeId} with text "${text}"`)).toBeInTheDocument()
-       })
-       return this
-     },
- 
-     expectGeneratedKey: async (key: string) => {
-       await waitFor(() => {
-         expect(screen.getByText(key)).toBeInTheDocument()
-       })
-       return this
-     },
- 
-     waitForElement: async (text: string) => {
-       await waitFor(() => {
-         expect(screen.getByText(text)).toBeInTheDocument()
-       })
-       return this
-     }
-   }
+     }
+   }
  
-   // WHEN - Perform user actions and interactions
+   // WHEN - User interactions
    when = {
      clickPing: async () => {
-       const pingButton = this.get.pingButton()
-       await this.user.click(pingButton)
-       return this
-     },
- 
-     typeMessage: async (message: string) => {
-       const messageInput = this.get.messageInput()
-       await this.user.type(messageInput, message)
-       return this
-     },
- 
-     clickSend: async () => {
-       const sendButton = this.get.sendButton()
-       await this.user.click(sendButton)
-       return this
-     },
- 
-     sendMessage: async (message: string) => {
-       await this.when.typeMessage(message)
-       await this.when.clickSend()
-       return this
-     },
- 
-     simulateTextClick: async (nodeId: string, text: string) => {
-       const mockRegisterMessageHandler = vi.mocked(UI_CHANNEL.registerMessageHandler)
-       const textClickHandler = mockRegisterMessageHandler.mock.calls.find(
-         call => call[0] === 'textClicked'
-       )?.[1] as unknown as (nodeId: string, text: string) => void
-       
-       if (textClickHandler) {
-         textClickHandler(nodeId, text)
-       }
-       return this
-     },
- 
-     clickGenerateKey: async () => {
-       const generateButton = this.get.generateKeyButton()
-       await this.user.click(generateButton)
+       await this.user.click(this.get.pingButton())
        return this
      }
    }
  
-   // SET - Configure mocks, setup, and test state
+   // SET - Setup and configuration
    set = {
      reset: () => {
```

```diff
        const bootstrapCallback = this.mockSetBootstrapCallback.mock.calls[0][0]
        bootstrapCallback(true)
-       await waitFor(() => screen.getByText('🎯 Figma Plugin'))
+       await waitFor(() => this.get.mainTitle())
        return this
      },
```

```diff
        this.mockRequest.mockResolvedValue(result)
        return this
-     },
- 
-     mockRequestError: (error: Error) => {
-       this.mockRequest.mockRejectedValue(error)
-       return this
      }
    }
```

---

<think><details><summary>Thought Process</summary>Let me fix the linter errors. I need to:

1. Fix the linter error in the interceptPostMessage.ts file about payload being possibly undefined
2. Fix the linter error in the vitest test file about the Promise issue

Let me fix these issues:</details></think>

---

Now I need to fix the linter errors. Let me address them:

---

```diff
            
            if (mockResponses[eventName]) {
-             const responseText = mockResponses[eventName](payload);
+             const responseText = mockResponses[eventName](payload || []);
              
              window.dispatchEvent(new MessageEvent('message', {
```

---

```diff
  
    it('should render basic UI elements', async () => {
-     await driver
+     const readyDriver = await driver
        .set.renderApp()
        .set.makePluginReady()
-       .get.expectMainUI()
+     
+     readyDriver.get.expectMainUI()
    })
  
    it('should handle ping communication', async () => {
-     await driver
+     const readyDriver = await driver
        .set.loadReadyApp()
        .set.mockRequestSuccess('pong response')
-       .when.clickPing()
-       .get.expectPingRequest(1)
+     
+     const afterClick = await readyDriver.when.clickPing()
+     afterClick.get.expectPingRequest(1)
    })
  }) 
```

---



---

